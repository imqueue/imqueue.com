---
layout: default
title: "Introduction"
section_id: intro
---

<div class="full">
    <div class="row">
        <div class="content">
            <div class="special-title centered-text">
                <i class="icon-info-circled goldenrod-text"></i>
                <h1>{{ page.title }}</h1>
                <p>
                    IMQ is an Intercommunication Messaging Queue Framework for service
                    oriented back-end architectures<br>built with Node and/or Typescript
                </p>
                <p class="shortline"></p>
                <div class="spacing"></div>
            </div>

            <p>There are several key capabilities:</p>

            <ul>
                <li>Massaging Queue as a base communication protocol between services (<a href="https://github.com/imqueue/core">@imqueue/core</a>)</li>
                <li>RPC-like programming interface (<a href="https://github.com/imqueue/rpc">@imqueue/rpc</a>)</li>
                <li>Rapid application development command line interface (<a href="https://github.com/imqueue/cli">@imqueue/cli</a>)</li>
            </ul>

            <p>
                These provides an ability for developers to create back-end services
                (or microservices as a special case of SOA) very fast and focus only
                on functionality implementation without need to take care of low-level
                implementation, following the next key principals:
            </p>
        </div>
    </div>
</div>

<div class="full light-grey">
    <div class="row special-title">
        <i class="icon-gears goldenrod-text"></i>
        <h2>Reliability</h2>
        <p class="line"></p>
        <div class="spacing"></div>
    </div>
    <div class="row">
        <p>
            IMQ implements <strong>reliable communication</strong> between services.
            Depending on the exact needs with use of <strong>safe delivery</strong> messaging
            and <strong>"leader" - "follower" deployment</strong> of messaging back-end engine
            it is possible to obtain full guarantee of data delivery between
            services.
        </p>
    </div>
</div>

<div class="full light-yellow">
    <div class="row special-title">
        <i class="icon-resize-full goldenrod-text"></i>
        <h2>Scalability</h2>
        <p class="line"></p>
        <div class="spacing"></div>
    </div>
    <div class="row">
        <p>
            IMQ supports several scaling possibilities on a different levels:
            <ul>
                <li><strong>Clustering</strong> backend engine (Redis)</li>
                <li><strong>Fork-based scaling</strong> on single machine to utilize all its cores</li>
                <li><strong>Network based horizontal scaling</strong>, running as much service copies as needed across multiple servers</li>
            </ul>
        </p>
        <p>
            Taking into account all that there are <strong>no technical limits</strong>
            to handle any possible throughput in the designed system based on IMQ.
        </p>
    </div>
</div>
<div class="full yellow">
    <div class="row special-title">
        <i class="icon-dot white-text"></i>
        <h2>Simplicity</h2>
        <p class="line"></p>
        <div class="spacing"></div>
    </div>
    <div class="row">
        <p>
            IMQ follows KISS (keep it short and simple) principals, making development
            using @imqueue easy and clear.
            <ul>
                <li><strong>Low-level entry threshold for JS/Typescript developers</strong> - only couple of minutes needed to implement first basic service</li>
                <li><strong>No need of very specific "hidden knowledge"</strong> to have to develop services with @imqueue</li>
                <li>Clean and easy to understand <strong>JSON-based messaging protocol</strong></li>
                <li>Based on <strong>well-known, easy to understand patters</strong>, like Messaging Queue and RPC (remote procedure calls)</li>
                <li><strong>Simple configuration</strong>. Being flexible from one hand @imqueue provides meaningful amount of configuration options to satisfy different needs</li>
            </ul>
        </p>
        <p>
            Usually all you need to create a service is only run a command which
            will create a named service from boilerplate and write your implementation
            as simple as writing class methods, exposing them. Then just run a
            service and it is ready to use by auto-generated service client at
            another network point.
        </p>
    </div>
</div>
<div class="full gray white-text">
    <div class="row special-title">
        <i class="icon-gauge goldenrod-text"></i>
        <h2>Performance</h2>
        <p class="line"></p>
        <div class="spacing"></div>
    </div>
    <div class="row">
        <p>
            We tried to take max is possible from the technologies IMQ is based on.
            Benchmarking is a part of @imqueue/core, so it is possible
            to run and test it in your environment.
        </p>
        <p>
            Here are some results we got on a single Intel Core i7 machine using
            1 dedicated core for Redis process and 6 workers each assigned to
            it's own core by using 1Kb message sent asynchronously 10,000 times
            at a time:
        </p>
            <ul>
                <li>For unsafe delivery communication it is fluctuated between <strong>40,000 - 50,000</strong> round-trips of messages per second</li>
                <li>For safe delivery communication it is around <strong>20,000 - 25,000</strong> round-trips of messages per second</li>
                <li>With a use of compression around it is <strong>20,000 - 25,000</strong> round-trips of messages per second</li>
            </ul>
        </p>
        <p>
            So in the worst case with all features turned on we can talk about
            <strong>tens of thousands</strong> messages round-trips per second for a
            single messaging backend engine which is fair enough to launch
            projects with pretty high load.
        </p>
    </div>
</div>
<div class="full dark-blue white-text">
    <div class="row special-title">
        <i class="icon-upload-cloud goldenrod-text"></i>
        <h2>Delivery</h2>
        <p class="line"></p>
        <div class="spacing"></div>
    </div>
    <div class="row">
        <p>
            IMQ respects smooth abd clean development and delivery processes.
            By using command line tool it provides extensible
            way to organize service delivery based on your own needs. Currently it
            provides a default template which includes <strong>Git</strong>,
            <strong>Travis CI</strong> and <strong>Docker</strong> /
            <strong>DockerHub</strong> integration out-of-the-box.
        </p>
        <p>
            Thus is a big plus it allows to define custom boilerplate
            templates which will modify or provide completely another
            ways of delivery on your side.
        </p>
        <div class="spacing"></div>
        <div class="spacing" style="margin-top:50px"></div>
        <div class="special-title centered-text">
            <h2>How Does It Work?</h2>
            <p>Explaining @imqueue internals</p>
            <p class="shortline"></p>
            <div class="spacing"></div>
        </div>
        <div class="spacing"></div>
        <img class="medium-4 columns right" src="/images/base-schema.svg">
        <p>
            IMQ implements messaging queue over Redis, which works as centralized
            message broker for communication between services and their clients.
        </p>
        <p>
            Such schema gives several advantages:
            <ul>
                <li>Simplicity (take a look at it!)</li>
                <li>
                    No need to implement any kind of <em>service discovery</em>, as it is
                    auto-discoverable schema - service instances compete for their messages,
                    so as far as instance is busy or down message will be consumed
                    by another instance and will deliver the response to a proper
                    client any way. It means there is no need to check if exact copy
                    of the service instance is dead or alive.
                </li>
                <li>
                    All messages are flowing through a single system point and can
                    be <em>easily monitored</em>, which simplifies debugging and monitoring
                    as far as Redis provides complete set of tools doing that.
                </li>
            </ul>
        </p>
        <h3>Fom Development Point Of View</h3>
        <p>
            So naturally each Service is a simple piece of software inside distributed
            system solving some specific task in it. That means that from development
            point of vew it is a simple as implementing class with an exposed methods.
            As follows from that a Client is a local representation of a remote Service
            interface at this exact network point. All you need when it is required to
            call a certain Service method is to call a corresponding Client method,
            where Client will take care about delivering proper message to a queue
            and that massage will invoke corresponding Service method execution.
        </p>
        <p>Yes, at development level it simply looks like <em>remote procedures calls</em>!</p>
        <p>
            There is no need of manual implementation of the clients. All @imqueue
            services are self-describable and clients could be generated dynamically
            on-the-fly or to be pre-auto-generated files. That means that developer
            should <em>be focused only on service implementation</em>. Following
            the simple rules and best practices when developing a Service interface,
            writing the proper doc-blocks you'll get all-in-one:
            <ul>
                <li>Implementation at one place</li>
                <li>Auto-generated client code whenever it is needed</li>
                <li>Auto-generated service-related documentation</li>
                <li>IDE service-related code auto-completions</li>
            </ul>
        </p>
        <p><a href="/get-started">Are you ready to try it?</a></p>
    </div>
</div>
